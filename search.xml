<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++模板</title>
    <url>/2023/07/31/C++%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p>模板就是建立<strong>通用的模具</strong>，大大<b>提高复用性</b></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li><p>C++另一种编程思想称为 <mark>泛型编程</mark> ，主要利用的技术就是模板</p>
</li>
<li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p>
</li>
</ul>
<h3 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h3><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：<mark>自动类型推导</mark>、<mark>显示指定类型</mark></li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h3 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h3><p>注意事项：</p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p>
</li>
<li><p>模板必须要确定出T的数据类型，才可以使用</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h3 id="函数模板案例"><a href="#函数模板案例" class="headerlink" title="函数模板案例"></a>函数模板案例</h3><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li><mark>普通函数调用时可以发生自动类型转换（隐式类型转换）</mark></li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><p>调用规则如下：</p>
<ol>
<li><mark>如果函数模板和普通函数都可以实现，优先调用普通函数</mark></li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li><mark>如果函数模板可以产生更好的匹配,优先调用函数模板</mark></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<strong>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</strong></p>
<h3 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h3><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h3><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h3 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h3><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h3 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h3 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h3><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<blockquote>
<p>案例：<strong>未完待续</strong></p>
</blockquote>
<h1 id="初识STL"><a href="#初识STL" class="headerlink" title="初识STL"></a>初识STL</h1><h2 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h2><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h2><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h2 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h2><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​	<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​	<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O流</title>
    <url>/2023/06/23/IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1、文件</p>
<p>保存数据的地方</p>
<p>2、 文件流</p>
<ul>
<li>流：数据在数据源(文件)和程序(内存)之间的路径</li>
<li>输入流：将磁盘中的文件写入内存</li>
<li>输出流：将内存中的内容写入磁盘</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>创建文件对象相关的构造器和方法<ul>
<li><code>new File(String pathname)</code>根据路径创建一个File对象</li>
<li><code>new File(File parent,String chil)</code>根据父目录文件+子路径构建</li>
<li><code>new File(String parent,String child)</code>根据父目录+子路径构建</li>
<li>createNewFile创建新文件</li>
</ul>
</li>
<li>获取文件的相关信息<ul>
<li>getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</li>
</ul>
</li>
<li>目录操作和文件删除<ul>
<li>创建一级目录：mkdir</li>
<li>创建多级目录：mkdirs</li>
<li>删除空目录或文件：delete</li>
</ul>
</li>
</ul>
<h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><ul>
<li><p>Java IO原理</p>
<ol>
<li>IO流是input、output的缩写，用于处理数据传输，如读写文件、网络通信</li>
<li>在Java程序中，对于数据的输入。输出以“流(stream)”的方式进行</li>
<li>java.io包下提供了各种“流”的类和接口，用于获取不同种类的数据，并通过方法输入或输出数据</li>
</ol>
</li>
<li><p>流的分类</p>
<ol>
<li><p>操作数据单元：字节流、字符流</p>
</li>
<li><p>数据流的流向：输入流、输出流</p>
</li>
<li><p>流的角色：节点流、处理流(字符流)</p>
<p><img src="https://raw.githubusercontent.com/czlifetime/img/master/img//img/IO%E6%B5%81%E5%A4%A7%E7%BA%B2.png"></p>
</li>
</ol>
</li>
</ul>
<h2 id="输入流"><a href="#输入流" class="headerlink" title="*输入流"></a>*输入流</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p><img src="https://raw.githubusercontent.com/czlifetime/img/master/FileInputStream.png"></p>
<h3 id="Reader-字节输入流"><a href="#Reader-字节输入流" class="headerlink" title="Reader(字节输入流)"></a>Reader(字节输入流)</h3><ul>
<li>关系图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/czlifetime/img/master/FileReader%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><ol>
<li>相关方法<ul>
<li><code>new FileReader(File/String)</code></li>
<li><code>read</code>:每次读取单个字符，返回该字符，如果到文件末尾，返回-1</li>
<li><code>read(char[])</code>:批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾，返回-1</li>
</ul>
</li>
<li>相关API<ul>
<li><code>new String(char[])</code>:将char[]转成String</li>
<li><code>new String(char[],off,len)</code>:将char []的指定部分转换成String</li>
</ul>
</li>
</ol>
<h2 id="输出流"><a href="#输出流" class="headerlink" title="*输出流"></a>*输出流</h2><h3 id="OutputStream-字节"><a href="#OutputStream-字节" class="headerlink" title="OutputStream(字节)"></a>OutputStream(字节)</h3><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p><img src="https://raw.githubusercontent.com/czlifetime/img/master/FileInputStream.png"></p>
<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><h3 id="Writer-字符"><a href="#Writer-字符" class="headerlink" title="Writer(字符)"></a>Writer(字符)</h3><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><ol>
<li>常用方法<ul>
<li>new FileWriter(File&#x2F;String):覆盖模式，相当于流的指针在首段</li>
<li>new FileWriter(File&#x2F;String,true):追加模式，相当于流的指针在尾端</li>
<li>write(int):写入单个字符</li>
<li>write(char[]):写入指定数组</li>
<li>write(char[],off,len):写入指定数组的指定部分</li>
<li>writer(string):写入指定字符串</li>
<li>writer(string,off,len):写入指定字符串放入指定部分</li>
</ul>
</li>
<li>相关API<ul>
<li>String类</li>
<li>toCharArray:将String转换成char[]</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/czlifetime/img/master/FileWriter%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<ul>
<li>注意：FileWriter使用后，必须关闭(close)或刷新(flush)，否则写入不到指定文件</li>
</ul>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ol>
<li>节点流可以从一个特定的数据源读取数据，如FileReader、FileWriter<ul>
<li>文件节点流：FileInputStream、FileOutputStream、FileReader、FileWriter</li>
<li>数组节点流：ByteArrayInputStream、ByteArrayOutStream、CharAttayReader、CharArrayWriter</li>
<li>访问管道、访问字符流</li>
</ul>
</li>
<li>处理流(包装流)是”连接”在已存在的流(节点流或处理流)之上，为程序提供更为强大的读写功能，更加灵活，如BufferedReader、BufferedWriter</li>
<li>节点流与处理流的区别与联系<ul>
<li>节点流是底层流&#x2F;低级流，直接跟数据源相接</li>
<li>处理流包含节点流，及可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li>
<li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/czlifetime/img/master/%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%A4%84%E7%90%86%E6%B5%81.png"></p>
<ol start="4">
<li><p>标准输入输出流</p>
<table>
<thead>
<tr>
<th></th>
<th>类型(编译类型)</th>
<th>类型(运行类型)</th>
<th>默认设备</th>
</tr>
</thead>
<tbody><tr>
<td>System.in标准输入</td>
<td>InputStream</td>
<td>BufferedInputStream</td>
<td>键盘</td>
</tr>
<tr>
<td>System.out标准输出</td>
<td>PrintStream</td>
<td>PrintStream</td>
<td>显示器</td>
</tr>
</tbody></table>
</li>
<li><p>转换流-InputStreamReader和OutputStreamWriter</p>
<ul>
<li>解决文件乱码问题</li>
</ul>
</li>
<li><p>打印流-PrintStream和PrintWriter</p>
<ul>
<li>打印流只有输出流</li>
<li>PrintStream(字节流)</li>
<li>PrintWriter(字符流)</li>
</ul>
</li>
</ol>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><ol>
<li>序列化：在保存数据时，保存数据的值和数据类型</li>
<li>反序列化：在恢复数据时，恢复数据的值和数据类型</li>
<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的(实现接口：Serializable或Externalizable)<ul>
<li>Serializable:标记接口，没有方法</li>
<li>Externalizable:该接口有方法需要实现</li>
</ul>
</li>
</ol>
<p>##Properties类</p>
<ol>
<li>专门用于读取配置文件的的集合类<ul>
<li>配置文件格式：键&#x3D;值</li>
</ul>
</li>
<li>注意：键值对不需要有空格，值不需要用引号括起来。默认类型是String</li>
<li>常见方法：<ul>
<li>load：加载配置文件的键值对到Properties对象</li>
<li>list：将数据显示到指定设备</li>
<li>getProperty(key):根据键获取值</li>
<li>setProperty(key,value):设置键值对到Properties对象</li>
<li>store:将Properties中的键值对存储到配置文件中，在idea中，保存信息到配置文件，如果含有中文，会存储为UNICode码</li>
</ul>
</li>
</ol>
<p>作用：存储和读取数据</p>
<p>I：input</p>
<p>O：output</p>
<p>流：像水流一样传输数据</p>
<h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><p><img src="https://github.com/czlifetime/img/blob/1.0/img/IO%E6%B5%81.png?raw=true"></p>
<p><img src="https://raw.githubusercontent.com/czlifetime/img/master/%E5%AD%97%E8%8A%82%E6%B5%81.png"></p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="FileOutputStream-1"><a href="#FileOutputStream-1" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>操作本地文件的字节输出流，可以把程序中的数据写到本地文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamText</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123; <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="comment">//步骤：</span></span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>)<span class="comment">//创建对象的路径</span></span><br><span class="line">        <span class="comment">//2.写出数据</span></span><br><span class="line">        fos.write(<span class="number">97</span>);</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：a</p>
<ul>
<li>创建对象细节：<ul>
<li>参数是字符串表示的路径或者是File对象都是可以的</li>
<li>如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的。</li>
<li>如果文件已经存在,则会清空文件</li>
</ul>
</li>
<li>写出数据细节：<ul>
<li>write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符</li>
</ul>
</li>
<li>释放资源细节：<ul>
<li>每次使用完流之后都要释放资源</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>						<span class="comment">//一次写一个字节数据</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>					<span class="comment">//一次写一个字节数组数据</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span>	<span class="comment">//一次写一个字节数组的部分数据</span></span><br></pre></td></tr></table></figure>

<h4 id="FileInputStream-1"><a href="#FileInputStream-1" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p>操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamText</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotException&#123;</span><br><span class="line">        <span class="comment">//步骤：</span></span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.读取数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建对象细节：如果文件不存在，直接报错</p>
</li>
<li><p>读取数据细节：</p>
<ul>
<li>一次读取一个字节，读出来的就是数据在ASCII上对应的数字</li>
<li>读到文件末尾，read方法返回-1</li>
</ul>
</li>
<li><p>释放资源细节：每次使用完流之后都要释放资源</p>
</li>
</ul>
<h4 id="字节输入流循环读取"><a href="#字节输入流循环读取" class="headerlink" title="字节输入流循环读取"></a>字节输入流循环读取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamText</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.tet&quot;</span>);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BytestreamText</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\原路径.mp4&quot;</span>);</span><br><span class="line">        <span class="type">FileOutStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象编程</title>
    <url>/2023/07/31/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h3><ul>
<li>方法是程序中最小的执行单元</li>
<li>方法的定义：把一些代码打包在一起</li>
</ul>
<h3 id="方法的格式"><a href="#方法的格式" class="headerlink" title="方法的格式"></a>方法的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名（参数）&#123;</span><br><span class="line">    方法体</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul>
<li>在同一个类中，定义多个同名的方法</li>
<li>每个方法都有不同的参数类型或参数个数，同名的方法之间就构成了重载关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法的内存"><a href="#方法的内存" class="headerlink" title="方法的内存"></a>方法的内存</h3><h5 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h5><ol>
<li>栈</li>
</ol>
<ul>
<li>方法运行时使用的内存，方法进栈运行，运行完毕出栈（先进后出）</li>
<li>变量</li>
</ul>
<ol start="2">
<li>堆</li>
</ol>
<ul>
<li>new出来，并产生地址</li>
</ul>
<ol start="3">
<li>方法区：字节码文件加载是进入的内存</li>
<li>本地方法栈</li>
<li>寄存器</li>
</ol>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h2 id="1-构造方法有什么作用？"><a href="#1-构造方法有什么作用？" class="headerlink" title="1.构造方法有什么作用？"></a>1.构造方法有什么作用？</h2><p>构造方法是一个比较特殊的方法，通过构造方法可以<code>完成对象的创建，以及实例变量的初始化</code>。<br>换句话说：构造方法是用来<code>创建对象，并且同时给对象的属性赋值</code>。<br><strong>注意</strong>：实例变量没有手动赋值的时候，系统会赋默认值。</p>
<h2 id="2-构造方法怎么定义，语法是什么？"><a href="#2-构造方法怎么定义，语法是什么？" class="headerlink" title="2.构造方法怎么定义，语法是什么？"></a>2.构造方法怎么定义，语法是什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形式参数列表)&#123;</span><br><span class="line">	构造方法体;</span><br><span class="line">	通常在构造方法体当中给属性赋值，完成属性的初始化。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>第一：修饰符列表目前统一写：<code>public</code>。千万不要写public static。</li>
<li>第二：构造方法名和<code>类名</code>必须<code>一致</code>。</li>
<li>第三：构造方法<code>不需要</code>指定<code>返回值类型</code>，也不能写void，写上void表示普通方法，就不是构造方法了。</li>
</ol>
<p>普通方法的语法结构是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-构造方法怎么调用，使用哪个运算符？"><a href="#3-构造方法怎么调用，使用哪个运算符？" class="headerlink" title="3.构造方法怎么调用，使用哪个运算符？"></a>3.构造方法怎么调用，使用哪个运算符？</h2><p>使用<code>new</code>运算符来调用构造方法。</p>
<h2 id="标准的JavaBean类"><a href="#标准的JavaBean类" class="headerlink" title="标准的JavaBean类"></a>标准的JavaBean类</h2><ol>
<li><p>类名需要见名知意</p>
</li>
<li><p>成员变量使用private修饰</p>
</li>
<li><p>提供至少两个构造方法</p>
<ul>
<li>无参构造方法</li>
<li>带全部参数的构造方法</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li>提供每一个成员变量对应的<code>setXxx()/getXxx()</code></li>
<li>如果还有其他行为，也需要写上</li>
</ul>
</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String概述"><a href="#String概述" class="headerlink" title="String概述"></a>String概述</h3><p><code>java.lang.String</code>类代表字符串，Java程序中所有的字符串文字都为此类</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>字符串的内容是不会发生改变的，他的对象在创建后不能被改变</p>
<h3 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h3><ol>
<li><p>直接赋值</p>
</li>
<li><p>通过new关键字，使用不同的构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String ()</td>
<td>创建空白字符串，不含任何内容</td>
</tr>
<tr>
<td>public String(String original)</td>
<td>根据传入的字符串，创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组，创建字符串对象</td>
</tr>
<tr>
<td>public String (byte[] chs)</td>
<td>根据字节数组，创建字符串对象</td>
</tr>
</tbody></table>
</li>
<li><p>字符串赋值</p>
<p>当双引号直接赋值时，系统会检查该字符串在串池中是否存在</p>
<ul>
<li>不存在：创建新的</li>
<li>存在：复用</li>
</ul>
</li>
</ol>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ol>
<li><p>比的到底是啥</p>
<ul>
<li>基本数据类型-&gt;数据值</li>
<li>引用数据类型-&gt;地址值</li>
</ul>
</li>
<li><p>比较方法</p>
<ul>
<li><p><code>boolen equal(要比较的字符串)</code>完全一样结果才是true，否则为false</p>
</li>
<li><p><code>boolen equalslgnoreCase(要比较的字符串)</code>忽略大小写的比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StingText</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rus1</span> <span class="operator">=</span> s1.equals(s);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rus2</span> <span class="operator">=</span> s1.equalsIgnoreCase(s);</span><br><span class="line">        System.out.print(rus1 + <span class="string">&quot; &quot;</span>+ rus2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：true true</p>
</li>
<li><p>如果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StingText</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> sc.next();<span class="comment">//.next()的核心是new出来的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span>  <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(str1 == str2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>请输入一个字符串：abc false 进程已结束,退出代码0</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>是一个容器，创建后里面的内容可变</p>
<ul>
<li>作用：提高字符串的操作效率</li>
</ul>
<h4 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h4><ul>
<li><p><code>public StringBuilder append () </code>     添加数据并返回数据本身</p>
</li>
<li><p><code>public StringBuilder reverse()</code>     翻转容器中的内容</p>
</li>
<li><p><code>public int length()</code>           返回长度</p>
</li>
<li><p><code>public String toString()</code>通过toString就可以实现把StringBuilder转换成String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderText</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建对象</span></span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//2.添加元素</span></span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.翻转</span></span><br><span class="line">        sb.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.长度</span></span><br><span class="line">        sb.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将StringBuilder变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>当在调用一个方法时，不需要用变量接受他的结果，可以调用其他方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">lianshibiancheng</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getString().length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a><code>StringJoiner</code></h3><p>##Static</p>
<ul>
<li><p>表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量</p>
</li>
<li><p>被static修饰的成员变量(静态变量)</p>
<ol>
<li><p>特点：</p>
<ul>
<li>被该类所有对象共享</li>
</ul>
</li>
<li><p>调用方式：</p>
<ul>
<li>类名调用</li>
<li>对象名调用</li>
</ul>
</li>
</ol>
</li>
<li><p>被static修饰的成员方法(静态方法)</p>
<ol>
<li><p>特点：</p>
<ul>
<li>多用在测试类，工具类中(注：测试类：用来检查其他的类是否书写正确，带有main方法的类，是程序的入口。工具类：不是用来描述一类事物的，而是帮助我们做一些事情的类。)</li>
<li>JavaBean类中很少</li>
</ul>
</li>
<li><p>调用方式：</p>
<ul>
<li>类名调用</li>
<li>对象名调用</li>
</ul>
</li>
</ol>
</li>
<li><p>注意事项：</p>
<ul>
<li>静态方法只能访问静态变量和静态方法</li>
<li>非静态方法可以访问所有</li>
<li>静态方法中没用this关键字</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>Java中提供一个关键字extends</p>
<p><code>public class Student extends person&#123;&#125;</code></p>
</li>
<li><p>好处：</p>
<ol>
<li>可以把多个子类中重复的代码抽取到父类中，提高代码的复用性</li>
<li>子类可以在父类的基础上，增加其他的功能，使子类更强大</li>
</ol>
</li>
<li><p>特点：支持单继承，不支持多继承，但支持多层继承（每一个类都直接或间接的继承于Object）</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9.png"></p>
<ul>
<li><p>父类的构造方法不能被子类继承</p>
</li>
<li><p>成员变量：private要有对应的set与get方法</p>
</li>
<li><p>只用父类中的虚方法表才能被子类继承</p>
</li>
</ul>
<h3 id="成员变量的访问特点"><a href="#成员变量的访问特点" class="headerlink" title="成员变量的访问特点"></a>成员变量的访问特点</h3><ol>
<li>就近原则：谁离我近，我就用谁</li>
<li>如果出现重名：<ul>
<li><code>name</code>从局部位置开始找</li>
<li><code>this.name</code>从本类成员位置开始往上</li>
<li><code>super.name</code>从父类成员位置开始往上</li>
</ul>
</li>
</ol>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><ul>
<li>当父类中的方法不能满足子类现在的需求时，需要进行方法重写（子类中的成员方法与父类中的成员方法名一样时）</li>
<li>要写上<code>@Override</code>重写注解,检验子类重写时语法是否正确</li>
</ul>
<h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><ul>
<li>将传递中虚方法表中的父类中的方法进行覆盖</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>重写方法的名称、形参列表必须与父类中的一致。</p>
</li>
<li><p>子类重写父类方法时，访问权限子类必须大于等于父类（暂时了解∶空着不写&lt;protected &lt; public</p>
</li>
<li><p>子类重写父类方法时，返回值类型子类必须小于等于父类</p>
</li>
<li><p>建议:重写的方法尽量和父类保持一致。</p>
</li>
<li><p>只有被添加到虚方法表中的方法才能被重写</p>
</li>
</ol>
<h3 id="继承中，构造方法的访问特点"><a href="#继承中，构造方法的访问特点" class="headerlink" title="继承中，构造方法的访问特点"></a>继承中，构造方法的访问特点</h3><ul>
<li>父类中的构造方法不会被子类继承</li>
<li>子类中所有的构造方法默认先访问父类中的无参构造，在执行自己</li>
<li>调用方式：super()</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>同类型的对象，表现出的不同形态</li>
</ul>
<ol>
<li><p>多态的表现形式：<code>父类类型 对象名称 = 子类对象</code></p>
</li>
<li><p>多态的前提</p>
<ul>
<li>有继承关系</li>
<li>有父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name&quot;</span> + name +<span class="string">&quot;age&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的信息为：&quot;</span> + getName() + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package CS408.polymorphism;</span><br><span class="line"></span><br><span class="line">public class Teacher extends Person&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void Show()&#123;</span><br><span class="line">        System.out.println(&quot;老师的信息为：&quot; + getName() + getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package CS408.polymorphism;</span><br><span class="line"></span><br><span class="line">public class Administrator extends Person&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void Show()&#123;</span><br><span class="line">        System.out.println(&quot;管理员的信息为：&quot; + getName() + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package CS408.polymorphism;</span><br><span class="line"></span><br><span class="line">public class Text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s = new Student();</span><br><span class="line">        Teacher t = new Teacher();</span><br><span class="line">        Administrator a = new Administrator();</span><br><span class="line">        s.setAge(19);</span><br><span class="line">        s.setName(&quot;张三&quot;);</span><br><span class="line">        t.setAge(29);</span><br><span class="line">        t.setName(&quot;李老师&quot;);</span><br><span class="line">        a.setAge(39);</span><br><span class="line">        a.setName(&quot;李管理&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        register(s);</span><br><span class="line">        register(t);</span><br><span class="line">        register(a);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void register(Person P)&#123;</span><br><span class="line">        P.Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态调用成员的特点"><a href="#多态调用成员的特点" class="headerlink" title="多态调用成员的特点"></a>多态调用成员的特点</h3><ul>
<li>调用成员变量：编译看左边，运行看左边</li>
<li>调用成员方法：编译看左边，运行看右边</li>
</ul>
<h3 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h3><ul>
<li>在多态的形式下，右边的对象可以实现解耦合，便于拓展和维护</li>
<li>定义方法的时候，使用父类型作为菜蔬，可以接受所有子类对象，体现多态的拓展性与遍历</li>
</ul>
<h3 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h3><ul>
<li><p>不能调用子类特有的功能</p>
</li>
<li><p>解决方法:变回子类类型</p>
<p><code>Dog d = (Dog) a;</code></p>
</li>
</ul>
<h3 id="弊端的解决方法"><a href="#弊端的解决方法" class="headerlink" title="弊端的解决方法"></a>弊端的解决方法</h3><ul>
<li>自动类型转换</li>
<li>强制类型转换<ul>
<li>可以转换成真正的子类类型，从而调用子类独有的功能</li>
<li>转换类型与真实对象类型不一致会报错</li>
<li>转换时用<code>instanceof</code>关键字进行判断</li>
</ul>
</li>
</ul>
<p>多态的综合练习: <a href="https://www.bilibili.com/video/BV17F411T7Ao?t=17.7&p=132">https://www.bilibili.com/video/BV17F411T7Ao?t=17.7&amp;p=132</a></p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>方法：表明该方法是最终方法，不能被重写</li>
<li>类：表明该类是最终类，不能被继承</li>
<li>变量：常量，只能被赋值一次<ul>
<li>修改基本数据类型：记录的值不能发生改变</li>
<li>修改引用数据类型：记录的地址值不能发生改变，内部的属性值还是可以改变的</li>
</ul>
</li>
</ul>
<p>final练习：<a href="https://www.bilibili.com/video/BV17F411T7Ao?t=2216.7&p=133%E5%8F%8A%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">https://www.bilibili.com/video/BV17F411T7Ao?t=2216.7&amp;p=133及学生管理系统</a></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li>局部代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">punlic <span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.print(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：提前结束变量的生命周期</p>
<ul>
<li>构造代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span> <span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构造代码块：写在成员位置的代码块</li>
<li>作用：可以把多个构造方法中重复的代码抽取出来</li>
<li>执行时机：先执行构造代码块再执行构造方法</li>
</ol>
<ul>
<li>静态代码块<ol>
<li>格式:<code>static&#123;&#125;</code></li>
<li>特点：需要通过static关键字修饰，随着累的加载而加载，并且自动触发，只执行一次</li>
<li>使用场景：在类的加载中，做数据的初始化使用</li>
</ol>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV17F411T7Ao?t=1866.9&p=134%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">https://www.bilibili.com/video/BV17F411T7Ao?t=1866.9&amp;p=134学生管理系统</a></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>作用：抽取共性时，无法确定方法体，就把方法定义为抽象的。强制让子类按照某种格式重写。抽象方法所在的类，必须是抽象类。</li>
<li>抽象方法：将共性的行为抽取到父类之后。将共性的行为(方法）抽取到父类之后。由于每一个子类执行的内容是不一样,所以，在父类中不能确定具体的方法体。该方法就可以定义为抽象方法。</li>
<li>抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类</li>
</ul>
<p>###定义格式</p>
<ul>
<li>抽象方法：<code>public abstract 返回值类型 方法名（参数列表）； </code></li>
<li>抽象类：<code>public abstract class 类名&#123;&#125;</code></li>
</ul>
<p>###抽象类和抽象方法注意事项</p>
<ul>
<li>抽象类不能创建对象</li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>
<li>抽象类可以有构造方法</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>是一种规则，是对行为的抽象</li>
</ul>
<h3 id="如何定义一个接口"><a href="#如何定义一个接口" class="headerlink" title="如何定义一个接口"></a>如何定义一个接口</h3><ul>
<li><p><code>public interface 接口名&#123;&#125;</code></p>
</li>
<li><p>不能实例化-&gt;不能new</p>
</li>
<li><p>接口与类是实现关系，通过implements关键字表示</p>
<ul>
<li><p>接口与类是实现关系，可以单实现，也可以多实现</p>
<p><code>public class 类名 implements 接口名1，接口名2&#123;&#125;</code></p>
</li>
<li><p>实现类可以继承一个类的同时实现多个接口</p>
<p><code>public class 类名extends implement 接口名1，接口名2&#123;&#125;</code></p>
</li>
</ul>
</li>
<li><p>接口的子类（实现类）</p>
<ul>
<li>要么重写接口中的所用抽象方法，要么是抽象类</li>
</ul>
</li>
</ul>
<h3 id="如何使用一个接口"><a href="#如何使用一个接口" class="headerlink" title="如何使用一个接口"></a>如何使用一个接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.InterfaceText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">animal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">animal</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.InterfaceText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.InterfaceText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rabbit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rabbit</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;兔子在吃胡萝卜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.InterfaceText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> <span class="keyword">implements</span> <span class="title class_">swim</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗在吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗在狗刨&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.InterfaceText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Frog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> <span class="keyword">implements</span> <span class="title class_">swim</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Frog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Frog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙在吃虫子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙在蛙泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.InterfaceText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Frog</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frog</span>(<span class="string">&quot;呱呱&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(f.getAge()+ <span class="string">&quot;,&quot;</span> + f.getName());</span><br><span class="line">        f.eat();</span><br><span class="line">        f.swim();</span><br><span class="line"></span><br><span class="line">        <span class="type">Rabbit</span> <span class="variable">ra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;小白&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(ra.getAge()+ <span class="string">&quot;,&quot;</span> + ra.getName());</span><br><span class="line">        ra.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,呱呱</span><br><span class="line">青蛙在吃虫子</span><br><span class="line">青蛙在蛙泳</span><br><span class="line"><span class="number">3</span>,小白</span><br><span class="line">兔子在吃胡萝卜</span><br></pre></td></tr></table></figure>

<h3 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h3><ul>
<li><p>成员变量</p>
<ul>
<li>只能是常量</li>
<li>默认修饰符：<code>public static final</code></li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>没有</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li>只是抽象方法</li>
</ul>
</li>
</ul>
<h3 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h3><ul>
<li>类与接口的关系<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>
</ul>
</li>
<li>接口与类的关系</li>
<li>接口与接口的关系<ul>
<li>继承关系，可以单继承，也可以多继承<ul>
<li>如果实现类实现了最下面的字接口，就需要重写所有的抽象方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li><p>编写带有接口和抽象类的标准<code>Javabean</code>类</p>
</li>
<li><p>我们现在有乒乓球运动员和篮球运动员，乒乓球教练和篮球教练。为了出国交流，跟乒乓球相关的人员都需要学习英语。<br>请用所有知识分析，在这个案例中，哪些是具体类，哪些是抽象类，哪些是接口?</p>
</li>
<li><p>乒乓球运动员:姓名，年龄，学打乒乓球，说英语<br>篮球运动员:姓名，年龄，学打篮球<br>乒乓球教练:姓名，年龄，教打乒乓球，说英语</p>
<p>篮球教练:姓名，年龄，教打篮球</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1Text%E6%80%9D%E8%B7%AF1.png"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1Text%E6%80%9D%E8%B7%AF2.png"></p>
<ul>
<li><pre><code class="java">package CS408.OopText;

public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  package CS408.OopText;</span><br><span class="line">  </span><br><span class="line">  public abstract class Athlete extends Person &#123;</span><br><span class="line">      public Athlete() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      public Athlete(String name,int age) &#123;</span><br><span class="line">          super(name,age);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public abstract void study();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">package CS408.OopText;

public abstract class Coach extends Person&#123;
    public Coach() &#123;
    &#125;

    public Coach(String name, int age) &#123;
        super(name, age);
    &#125;

    public abstract void teach();
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  package CS408.OopText;</span><br><span class="line">  </span><br><span class="line">  public class PingpangAthlete extends Athlete implements English&#123;</span><br><span class="line">      public PingpangAthlete() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public PingpangAthlete(String name, int age) &#123;</span><br><span class="line">          super(name, age);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void study()&#123;</span><br><span class="line">          System.out.println(&quot;乒乓球运动员学打乒乓球&quot;);</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void english()&#123;</span><br><span class="line">          System.out.println(&quot;乒乓球运动员学英语&quot;);</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">package CS408.OopText;

public class BasketballAthlete extends Athlete&#123;
    public BasketballAthlete() &#123;
    &#125;

    public BasketballAthlete(String name, int age) &#123;
        super(name, age);
    &#125;
    public void study()&#123;
        System.out.println(&quot;篮球运动员在学打篮球&quot;);
    &#125;
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  package CS408.OopText;</span><br><span class="line">  </span><br><span class="line">  public class BasketballCoach extends Coach&#123;</span><br><span class="line">      public BasketballCoach() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public BasketballCoach(String name, int age) &#123;</span><br><span class="line">          super(name, age);</span><br><span class="line">      &#125;</span><br><span class="line">      public void teach()&#123;</span><br><span class="line">          System.out.println(&quot;篮球教练在教打篮球&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">package CS408.OopText;

public interface English &#123;
    public abstract void english();
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  package CS408.OopText;</span><br><span class="line">  </span><br><span class="line">  public class Text &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          PingpangAthlete ppa = new PingpangAthlete(&quot;小花&quot;,20);</span><br><span class="line">          ppa.study();</span><br><span class="line">          ppa.english();</span><br><span class="line">  </span><br><span class="line">          BasketballAthlete ba = new BasketballAthlete(&quot;姚明&quot;, 24);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="其他接口方法"><a href="#其他接口方法" class="headerlink" title="其他接口方法"></a>其他接口方法</h3><p><a href="https://www.bilibili.com/video/BV17F411T7Ao?p=139">https://www.bilibili.com/video/BV17F411T7Ao?p=139</a></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>在类的里面再定义一个类，这个类教内部类</li>
<li>内部类的访问特点<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员必须创建对象</li>
</ul>
</li>
</ul>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ul>
<li>成员内部类<ul>
<li>写在成员位置，属于外部类成员</li>
</ul>
</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类<ul>
<li>本质：隐藏了名字的内部类<ul>
<li>格式：<code>new 类名或者接口名（）&#123;重写方法&#125;</code></li>
</ul>
</li>
<li>包含三个关系：继承\实现，方法重写，创建对象</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建个人博客</title>
    <url>/2023/05/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="从零开始搭建个人博客"><a href="#从零开始搭建个人博客" class="headerlink" title="从零开始搭建个人博客"></a>从零开始搭建个人博客</h1><hr>
<p>我为什么要搭建个人博客？</p>
<ol>
<li>记录美好生活；</li>
<li>提升自己的技术水平；</li>
<li>空闲时间娱乐；</li>
</ol>
<hr>
<p><font color = "red" size ="5">本博客由Github+Hexo搭建，下面我来介绍我做这个博客的全过程：</font></p>
<h2 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h2><ol>
<li><p>首先进入<a href="https://github.com/">GitHub官网</a></p>
</li>
<li><p>点击Sign up</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/26/4spkv6yjKPYq2Qt.png"></p>
<ol start="3">
<li><p>输入你要注册的邮箱、密码<img src="https://s2.loli.net/2023/05/26/w5rAt1McU8DfLZF.png"></p>
</li>
<li><p>Create account</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/26/qJ6LpkECcez42dF.png"></p>
<ol start="5">
<li>依次按照github的提示来做，之后就省略，不难。</li>
</ol>
<h2 id="Git安装步骤"><a href="#Git安装步骤" class="headerlink" title="Git安装步骤"></a>Git安装步骤</h2><ol>
<li><p>进入<a href="https://git-scm.com/">Git官网</a>,想、点击Downloads</p>
<p><img src="https://s2.loli.net/2023/05/26/XCvmpUekgtPsNc1.png"></p>
</li>
<li><p>选择自己的系统</p>
<p><img src="https://s2.loli.net/2023/05/26/NVbQZjwHz5kDGqx.png"></p>
</li>
<li><p>选择自己的适合的版本<img src="https://s2.loli.net/2023/05/26/NVbQZjwHz5kDGqx.png"></p>
</li>
</ol>
<p>​	( 国内下载的速度慢，有时候还会下载失败，我这里提供<a href="https://www.aliyundrive.com/s/32emvmTN9aV">Git-2.40.1-64-bit的安装包</a> )</p>
<ol start="4">
<li><p>下载完成打开</p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/yl4izRvqdTBLCn1.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/eNLwi4Sop3kAs8X.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/FmR3fzUq6wNl91H.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/uWtBQJraKdRG7Zh.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/rwGlm473aKEMWvA.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/D7NuTQsWAHjlrwy.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/TsWILrDS98yoOGb.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/Vn2f47LztITKk5p.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/Bzsw2Djd7FQc8m1.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/gmIUl8jCiRG2c5M.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/ECMy75odNPawH3b.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/SpCgHmPqcwUENIh.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/nERkNgU5zpiqxSX.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/NJkGvSWAt6wdFRH.png"></p>
</li>
<li><p><img src="https://s2.loli.net/2023/05/26/nHdCWkv5O92Sb3D.png"></p>
</li>
<li><p>鼠标左击出现这种情况就可以了</p>
<p><img src="https://s2.loli.net/2023/05/26/SQlBgaF2YvuLcCy.png"></p>
</li>
<li><p>打开Git Bash，输入git出现这种情况就可以了</p>
<p><img src="https://s2.loli.net/2023/05/26/ySnF47b2xWUaQ9i.png"></p>
</li>
</ol>
<h2 id="绑定GitHub并提交文件"><a href="#绑定GitHub并提交文件" class="headerlink" title="绑定GitHub并提交文件"></a>绑定GitHub并提交文件</h2><ol>
<li><p>打开Git bash 输入ssh，查看本机是否安装SSH</p>
<p><img src="https://s2.loli.net/2023/05/26/mKTCNa8wS2BYPuI.png"></p>
</li>
<li><p>输入<code>ssh-keygen -t rsa</code>，指定生成秘钥，接着再点击四次回车键，生成两个文件，分别为<code>id_rsa</code>，<code>id_rsa.pub</code>，按照指定的文件位置打开<code>id_rsa.pub</code>，复制下来</p>
<p><img src="https://s2.loli.net/2023/05/26/lmLI6WPkRhKiJcA.png"></p>
</li>
<li><p>打开github，在settings中<code>SSH and GPG keys</code>中添加秘钥，名称加不加都行</p>
<p><img src="https://s2.loli.net/2023/05/26/EesFogtycpwb3JV.png"></p>
<p><img src="https://s2.loli.net/2023/05/26/MK4F9RpHiC7OxIS.png"></p>
</li>
<li><p>验证是否成功，在Git Bash中输入<code>ssh -T github@github.com</code>进行验证</p>
<p><img src="https://s2.loli.net/2023/05/26/N8KvWDrzjohAwdb.png"></p>
</li>
</ol>
<h2 id="安装node-js和Hexo"><a href="#安装node-js和Hexo" class="headerlink" title="安装node.js和Hexo"></a>安装node.js和Hexo</h2><h3 id="安装node-js及环境变量适配"><a href="#安装node-js及环境变量适配" class="headerlink" title="安装node.js及环境变量适配"></a>安装node.js及环境变量适配</h3><p>大家可以看这篇<a href="https://blog.csdn.net/antma/article/details/86104068">文章</a>，内容相当的详细</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol>
<li><p>在github中新建一个仓库</p>
<p><img src="D:\Desktop\笔记\图片\GWQ2IX1NctS6TVR.png"></p>
</li>
<li><p>仓库名为<code>用户名+github.io</code></p>
<p><img src="https://s2.loli.net/2023/05/26/zHRwbt15yGinTIU.png"></p>
</li>
<li><p>点击到仓库的settings，出现这种情况就可以了</p>
<p><img src="https://s2.loli.net/2023/05/26/mevcw1kIht5UELn.png"></p>
</li>
<li><p>安装Hexo：在任意一个盘符下面新建一个<code>Blog</code>文件夹打开文件夹，使用git Bash 的管理员身份运行，输入<code>npm install -g hexo-cli</code>，安装完成之后，在使用<code>hexo init</code>命令初始化一下，输入<code>hexo g</code>静态部署，输入<code>hexo s</code>可以本地预览，在浏览器中输入<code>localhost:4000</code>，就可以本地预览网页了</p>
</li>
<li><p>将Hexo部署到GitHub中：打开Blog文件夹，打开<code>_config.yml</code>文件，滑到文件的最下方，修改</p>
<p><img src="https://s2.loli.net/2023/05/26/at2KjYhmLPAE84k.png"></p>
<p><img src="https://s2.loli.net/2023/05/26/16b3vVJNHitP4oX.png"></p>
<p><img src="https://s2.loli.net/2023/05/26/fSyYRl5OIFAJhcd.png"></p>
</li>
<li><p>然后回到<code>Blog</code>文件夹中，打开Git Bash，安装Git部署插件，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>再输入以下的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean #清除缓存文件db.json和已生成的静态文件public</span><br><span class="line">hexo g     #生成网站静态文件到默认设置的 public 文件夹(hexo generate的缩写)</span><br><span class="line">hexo d     #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入<code>你的用户名+github.io</code>就可以访问网站了</p>
</li>
</ol>
<h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><ol>
<li><p>域名绝大部分是付费的，但是也有免费的，比如我的这个czlifetime.eu.org，具体的申请教程在<a href="https://www.bilibili.com/video/BV1gs4y1J7xZ/?spm_id_from=333.880.my_history.page.click&vd_source=f38da837f7ffc103f340849927ff2d1f">这</a></p>
</li>
<li><p>得到域名后，在阿里云、腾讯云、华为云等可以解析，添加记录：A @ 185.199.108.153 和 A @ 185.199.109.153 和 A @ 185.199.110.153 和 A @ 185.199.111.153，任意选一个或两个就可以了</p>
</li>
<li><p>打开Blog文件夹里的source文件夹，添加CNAME文件，可以先创建一个CNAME.txt文件，打开后写上你的域名，不要加www否则每次访问都必须加www，但如果不带有www，以后访问的时候带不带www都可以访问，保存后记得要重命名，将.txt删除</p>
</li>
<li><p>第三步回到Blog 文件夹，右键打开Git Bash，依次输入下面三条命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean #清除缓存文件db.json和已生成的静态文件public</span><br><span class="line">hexo g     #生成网站静态文件到默认设置的 public 文件夹(hexo generate的缩写)</span><br><span class="line">hexo d     #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开GitHub，看看CNAME文件是否已经在你的项目中，如果没有，可以在github的仓库中添加，最后github中也要把你的域名写进去</p>
<p><img src="https://s2.loli.net/2023/05/26/Z5SmLtMvVpyW4T3.png"></p>
</li>
</ol>
<h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p><code>hexo</code>有很多种主题，我推荐8种主题</p>
<ol>
<li>Butterfly<ul>
<li>GitHub地址：<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a></li>
<li>在线演示：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></li>
</ul>
</li>
<li>ICARUS<ul>
<li>GitHub地址：<a href="https://github.com/ppoffice/hexo-theme-icarus">https://github.com/ppoffice/hexo-theme-icarus</a></li>
<li>在线演示：<a href="https://ppoffice.github.io/hexo-theme-icarus/">https://ppoffice.github.io/hexo-theme-icarus/</a></li>
</ul>
</li>
<li>Fluid<ul>
<li>GitHub地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></li>
<li>在线演示：<a href="https://hexo.fluid-dev.com/">hexo.fluid-dev.com&#x2F;</a></li>
</ul>
</li>
<li>Volantis<ul>
<li>GitHub地址：<a href="https://github.com/volantis-x/hexo-theme-volantis">https://github.com/volantis-x/hexo-theme-volantis</a></li>
<li>在线演示：<a href="https://volantis.js.org/">volantis.js.org</a></li>
</ul>
</li>
<li>Snippet<ul>
<li>GitHub地址：<a href="https://github.com/shenliyang/hexo-theme-snippet">https://github.com/shenliyang/hexo-theme-snippet</a></li>
<li>在线演示：<a href="https://snippet.shenliyang.com/">snippet.shenliyang.com&#x2F;</a></li>
</ul>
</li>
<li>Hacker<ul>
<li>GitHub地址：<a href="https://github.com/CodeDaraW/Hacker">https://github.com/CodeDaraW/Hacker</a></li>
<li>在线演示：<a href="https://blog.daraw.cn/">blog.daraw.cn&#x2F;</a></li>
</ul>
</li>
<li>3-hexo<ul>
<li>GitHub地址：<a href="https://github.com/yelog/hexo-theme-3-hexo">https://github.com/yelog/hexo-theme-3-hexo</a></li>
<li>在线演示：<a href="https://yelog.org/">yelog.org</a></li>
</ul>
</li>
<li>Cactus<ul>
<li>GitHub地址：<a href="https://github.com/probberechts/hexo-theme-cactus">https://github.com/probberechts/hexo-theme-cactus</a></li>
<li>在线演示：<a href="https://probberechts.github.io/hexo-theme-cactus/">probberechts.github.io&#x2F;hexo-theme-cactus&#x2F;</a></li>
</ul>
</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>点开GitHub的地址，详细的配置就在首页的md文件中，这里不过多赘述</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中&amp;和*的区别</title>
    <url>/2023/07/31/%E5%8F%96%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="C-中-和-amp-的区别"><a href="#C-中-和-amp-的区别" class="headerlink" title="C++中*和&amp;的区别"></a>C++中*和&amp;的区别</h1><ul>
<li>*是<mark>取值运算符</mark>，对地址使用可以获得地址中储存的数值。 对于指针a，*a表示取a中的值</li>
<li>&amp;是<mark>地址运算符</mark>，对变量使用可以获得该变量的地址。对于变量b，&amp;b表示取b的地址</li>
</ul>
<hr>
<p>在定义时，* 是一个标识符，声明该变量是一个指针，比如说int *p; 那p就是一个指向int型的指针；<br>在调用时，*p是指针p指向的那个变量，比如说之前有int a&#x3D;5；int *p&#x3D;a；那么p的值是a的地址，也就是指针p指向a，*p则等于a的值，即*p&#x3D;5。<br>而&amp;，则是引用，比如说有定义int a&#x3D;5；再定义int b&#x3D;&amp;a；那么这里的b则引用a的值，即b&#x3D;5，而再给b赋值：b&#x3D;10，a的值也会变为10。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2023/05/22/%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p><img src="https://s2.loli.net/2023/05/22/WTjnpNUAybvVCOE.png" alt="图的定义1.png"><img src="https://s2.loli.net/2023/05/22/FV6WkYfRIZOPbSo.png" alt="图的定义2.png" style="zoom:33%;" /></p>
</li>
<li><p>注意：</p>
<p>​	线性表可以是空表，树可以是空树，但图不可以是空，即v一定是非空集</p>
</li>
</ul>
<h3 id="无向图、有向图"><a href="#无向图、有向图" class="headerlink" title="无向图、有向图"></a>无向图、有向图</h3><p><img src="https://s2.loli.net/2023/05/22/cxqBhkDFXmNb4fC.png" alt="无向图.png"><img src="https://s2.loli.net/2023/05/22/WyAsc3gnGuLPSXQ.png" alt="有向图.png"></p>
<h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><ul>
<li>简单图</li>
<li>多重图</li>
</ul>
<h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><ul>
<li><p>无向图：顶点v的度是指依附于改顶点的边的条数，极左TD(v)</p>
</li>
<li><p>有向图：</p>
<p>​	入读是以顶点v为终点的有向边的数目，记为ID(v)</p>
<p>​	出度是以顶点v为起点的有向边的数目，记为OD(v)</p>
<p>​	顶点的度等于入度和出度之和，TD(v)&#x3D;ID(v)+OD(v)</p>
</li>
</ul>
<h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><ul>
<li><font color="red">路径</font>：顶点v1到顶点v2之间的一条路径</li>
<li><font color="red">回路</font>：第一个顶点和最后一个顶点相同的路径称为回路或环</li>
<li><font color="red">简单路径</font>：在路径序列中，顶点不重复出现的路径称为简单路径。</li>
<li><font color="red">简单回路</font>:除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li>
<li><font color="red">路径长度</font>:路径上边的数目</li>
<li><font color="red">点到点的距离</font>:从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷</li>
<li><font color="red">无向图</font>中，若从顶点v到顶点w有路径存在，则称v和w是<font color="red">连通</font>的</li>
<li><font color="red">有向图</font>中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<font color="red">强连通</font>的</li>
</ul>
<h2 id="几种特殊的图"><a href="#几种特殊的图" class="headerlink" title="几种特殊的图"></a>几种特殊的图</h2>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2023/07/30/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h1><h2 id="基本概念和排序方法"><a href="#基本概念和排序方法" class="headerlink" title="基本概念和排序方法"></a>基本概念和排序方法</h2><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><ol>
<li><strong>排序</strong>：从大到小或从小到大排序</li>
<li><strong>排序的稳定性</strong>：<ul>
<li>稳定的：关键字相同的元素在排序之后相对位置不变</li>
<li>不稳定：相反</li>
</ul>
</li>
<li>排序算法的分类：<ul>
<li>内部排序：待排序记录全部放在<mark>计算机内存</mark>中*(关注算法时间、空间复杂度)*</li>
<li>外部排序：数据过大，以至于内存中不能容纳全部的数据，在排序过程中，尚需对<mark>外存</mark>进行访问排序*(还要关注读取&#x2F;写磁盘的次数更少)*</li>
</ul>
</li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>算法思想</strong>︰每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>是一种最简单的排序方法，其基本操作是将一条记录插入已经排好序的表，从而得到一条新的、记录数量增1的有序表</p>
<p>算法描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E5%B8%A6%E5%93%A8%E5%85%B5%EF%BC%89.png" alt="()"></p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img//%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif"></p>
<p>算法分析：</p>
<ul>
<li><p>时间复杂度：</p>
<p>最好的情况：比较次数n-1次</p>
<p>最坏的情况：$$O(n^2)$$</p>
<p>平均时间复杂度：$$O(n^2)$$</p>
</li>
<li><p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png"></p>
<p>时间复杂度<mark>依然是$O(n^2)$</mark></p>
<p><strong>注意</strong>：一直到low&gt;high时才停止折半查找。当mid所指元素等于当前元素时，应继续令low&#x3D;mid+1，以保证“稳定性”。最终应将当前元素插入到low所指位置(即high+1)</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先追求表中元素部分有序，在逐渐逼近全局有序(<mark>部分有序</mark>-&gt;<mark>全局有序</mark>)</p>
<p><strong>希尔排序</strong>︰先将待排序表分割成若干形如$$L[i,i + d, i + 2d…, i + kd]$$的“特殊”子表，对各个子表分别进行直接插入排序。缩小<font color="red"><em>增量d</em>(每次将d减少一半)</font>，重复上述过程，直到d&#x3D;1为止。</p>
<p>算法实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif"></p>
<p><strong>算法性能分析</strong>：</p>
<p>空间复杂度：$$O(1)$$</p>
<p>时间复杂度：$$O(n^{1.25})~O(1.6n^{1.25})$$</p>
<p><strong>不稳定，仅适用于顺序表，不适用于链表</strong></p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>基本思想：</p>
<p>两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，一直到整个序列全部满足要求为止</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法实现：<br><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif"></p>
<p>算法性能分析：</p>
<p>空间复杂度：$$O(1)$$</p>
<p>时间复杂度：</p>
<p>最好：$$O(1)$$</p>
<p>最差：$$O(n^2)$$</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>算法思想</strong>∶在待排序表$$L[1..n]$$中任取一个元素$$pivot$$作为枢轴(或基准，通常取首元素)，通过一趟排序将待排序表划分为独立的两部分$$L[1…k-1]$$和$$LIk+1..n]$$，使得$$[1…k-1]$$中的所有元素小于$$pivot$$，$$L[k+1..n]$$中的所有元素大于等于$$pivot$$，则$$pivot$$放在了其最终位置$$L(k)$$上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif"></p>
<p>算法实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素假如有序子序列</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img//%25E9%2580%2589%25E6%258B%25A9%25E6%258E%2592%25E5%25BA%258F.gif"></p>
<p>空间复杂度：$$O(1)$$</p>
<p>时间复杂度：$$O(n^2)$$</p>
<h3 id="树型选择排序"><a href="#树型选择排序" class="headerlink" title="树型选择排序"></a>树型选择排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆的定义</strong>：n个元素的序列$${k_1,k_2,k_3,…,k_n}$$称之为堆，当且仅当满足以下条件时：</p>
<ul>
<li>$$k_i&gt;&#x3D;k_2i$$且$$k_i&gt;&#x3D;k_{2i+1}$$</li>
<li>$$k_i&lt;&#x3D;k_{2i}$$且$$k_i&lt;&#x3D;k_P{2i+1}(1&lt;&#x3D;i&lt;&#x3D;\lfloor{n&#x2F;2}\rfloor)$$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%A0%86.png"></p>
<p>大根堆：根&gt;&#x3D;左右节点</p>
<p>小根堆：根&lt;&#x3D;左右节点</p>
<ol>
<li><p>建立大根堆</p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86.png"></p>
</li>
</ol>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计思想</title>
    <url>/2023/06/23/%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><ul>
<li>统计思想:利用map集合进行统计</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul>
<li>遍历集合，按照指定的集合进行拼接的两种方式：<ul>
<li><code>StringBuilder</code></li>
<li><code>StringJoiner</code></li>
</ul>
</li>
</ul>
<h3 id="概率问题"><a href="#概率问题" class="headerlink" title="概率问题"></a>概率问题</h3><ul>
<li>如30%的甲，70%的乙：<ol>
<li>创建一个新的集合：赋30%的”1”，赋70%的”2”</li>
<li>对所创建的集合元素进行随机取值：<code>Random r = new Random();</code></li>
<li>对随机取得的值进行条件判断，取到的值就有概率</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CS408.CollectionText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text2</span> &#123;</span><br><span class="line">    <span class="comment">//班级里有N个学生要求:70%的概率随机到男生,30%的概率随机到女生</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        Collections.addAll(list,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Collections.addAll(list,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//从list中抽取1,0</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(list.size());</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> list.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个集合分别存储男生与女生</span></span><br><span class="line">        ArrayList&lt;String&gt; boyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; girlList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Collections.addAll(boyList,<span class="string">&quot;男1&quot;</span>,<span class="string">&quot;男2&quot;</span>,<span class="string">&quot;男3&quot;</span>,<span class="string">&quot;男4&quot;</span>,<span class="string">&quot;男5&quot;</span>,<span class="string">&quot;男6&quot;</span>,<span class="string">&quot;男7&quot;</span>,<span class="string">&quot;男8&quot;</span>,<span class="string">&quot;男9&quot;</span>);</span><br><span class="line">        Collections.addAll(girlList,<span class="string">&quot;女1&quot;</span>,<span class="string">&quot;女2&quot;</span>,<span class="string">&quot;女3&quot;</span>,<span class="string">&quot;女4&quot;</span>,<span class="string">&quot;女5&quot;</span>,<span class="string">&quot;女6&quot;</span>,<span class="string">&quot;女7&quot;</span>,<span class="string">&quot;女8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断此时是从boyList里抽取，还是从girlList中抽取</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">boyIndex</span> <span class="operator">=</span> r.nextInt(boyList.size());</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> boyList.get(boyIndex);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">girlIndex</span> <span class="operator">=</span> r.nextInt(girlList.size());</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> girlList.get(girlIndex);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对应思想"><a href="#对应思想" class="headerlink" title="对应思想"></a>对应思想</h3><ul>
<li><ul>
<li>如果原始数据的规律非常复杂，可以先手动排序让每一个数据跟唯一的序号产生对应关系</li>
<li>序号就是数字，规律简单，后续的所有操作，以序号为准</li>
<li>当真正需要操作数据的时候，通过序号找到原始数据即可</li>
</ul>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>把具体的要求封装成方法</li>
</ul>
]]></content>
      <tags>
        <tag>设计思想</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2023/05/19/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li><p>节点的内部结构</p>
<p><img src="/img/%E8%8A%82%E7%82%B9%E5%86%85%E9%83%A8.png"></p>
</li>
<li><p><img src="/img/%E6%95%B0%E4%B8%93%E4%B8%9A%E5%90%8D%E8%AF%8D.png"></p>
</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li>规则：任意节点左右子树不超过一</li>
<li>平衡二叉树的旋转机制<ul>
<li>左旋</li>
<li>右旋</li>
</ul>
</li>
</ul>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul>
<li>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。</li>
<li>1972年出现，当时被称之为平衡二叉B树。后来，1978年被修改为如今的”红黑树”。</li>
<li>它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，</li>
<li>每一个节点可以是红或者黑;红黑树不是高度平衡的，它的平衡是通过”红黑规则”进行实现的</li>
</ul>
<h2 id="红黑规则"><a href="#红黑规则" class="headerlink" title="红黑规则"></a>红黑规则</h2><ul>
<li>每一个节点或是红色的，或者是黑色的</li>
<li>根节点必须是黑色</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的</li>
<li>如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点;</li>
</ul>
<img src="红黑树节点.png" style="zoom:50%;" />

<ul>
<li>红黑树添加节点的规则：<ul>
<li>添加节点默认是红色(效率高)</li>
<li><img src="/红黑树添加节点的规则.png" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<p><strong>更多内容请见 :point_right:<a href="https://flowus.cn/czlifetime/4fe006af-a7d0-4ef3-94b9-09f775b9334d">链接</a></strong></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2023/07/20/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><ol>
<li><p>初始化</p>
<p><mark>步骤</mark>：</p>
<ol>
<li>为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址</li>
<li>将表的当前长度设为0</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!L.elem)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取值</p>
<p><mark>步骤</mark>:</p>
<ol>
<li>判断指定的位置序号i的值是否合理$$（1&lt;&#x3D;i&lt;&#x3D;L.length）$$，若不合理，返回false</li>
<li>若值合理，则将第i个数据元素L.elem[i-1]赋值参数e，通过e返回第i个数据元素的传值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<p><mark>步骤</mark>：</p>
<ol>
<li>从第一个元素起，依次将其值和e比较，若找到和e值相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1</li>
<li>若查遍整个顺序表都没有找到，则查找失败，返回0</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e==L.elem[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入</p>
<ol>
<li>判断插入位置i是否合法(i值的合法范围为1&lt;&#x3D;i&lt;&#x3D;n+1)，若不合法返回FALSE</li>
<li>判断顺序表的存储空间是否已满，若满了，返回FALSE</li>
<li>将第n个至第i个元素依次向后移动一个位置，空出第i个位置(i&#x3D;n+1时无序移动)</li>
<li>将要插入的元素e放入第i个元素</li>
<li>表长加一</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.length==MAXSIZE)&#123;<span class="comment">//判断顺序表的存储空间是否已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];    </span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i<span class="number">-1</span>] = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<p><mark>步骤</mark>:</p>
<ol>
<li>判断删除位置i是否合法(合法的值为1&lt;&#x3D;i&lt;&#x3D;n)，若不合法则返回FALSE</li>
<li>将第i+1个元素至第n个元素依次向前移动一个位置(i&#x3D;n时无需移动)</li>
<li>表长减一</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;L.length &amp;&amp; i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        L.elem[j<span class="number">-1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><mark>测试</mark>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(SqList &amp;L, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span> (!L.elem) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PushElem</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetElem</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LocateElem</span><span class="params">(SqList &amp;L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == L.elem[i]) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;位置为&quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) &#123; <span class="comment">//判断顺序表的存储空间是否已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--) &#123;</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; L.length &amp;&amp; i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个元素：&quot;</span> &lt;&lt; L.elem[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">PushElem</span>(L, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PushElem</span>(L, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">PushElem</span>(L, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">PushElem</span>(L, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">LocateElem</span>(L, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在第三个位置，插入元素5</span></span><br><span class="line">    <span class="built_in">ListInsert</span>(L, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ListDelete</span>(L, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>运行</mark>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/czlifetime/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png"></p>
<h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ol>
<li><p>初始化</p>
<ol>
<li>生成新节点作为头结点，用头指针L指向头结点</li>
<li>头结点的指针域置空</li>
</ol>
</li>
<li><p>取值</p>
<ol>
<li>用指针p指向首元结点，用j做计数器初值赋为1</li>
<li>从首元结点开始依次顺着链域next向下访问，只要指向当前节点的指针p不为空(NULL)，并且没有到达序号为i的节点，则循环执行以下操作：<ul>
<li>p指向下一节点</li>
<li>计数器j加一</li>
</ul>
</li>
<li>退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法(i大于表长n或i小于等于0)，取值失败返回ERROR；否则取值成功，此时j&#x3D;i时，p所指的节点就是要找的第i个节点，用参数e保存当前节点的数据域，返回OK</li>
</ol>
</li>
<li><p>查找</p>
<ol>
<li>用指针p指向首元结点</li>
<li>从首元结点开始依次顺着链域next向下查找，只要指向当前节点的指针p不为空，并且p所指节点的数据域不等于给定值e，则循环执行以下操作：p指向下一节点</li>
<li>返回p。若查找成功，p此时指向节点的地址值；若查找失败，则p的值为NULL</li>
</ol>
</li>
<li><p>插入</p>
<ol>
<li>查找节点a<sub>i-1</sub>并由指针p指向该节点</li>
<li>生成一个新节点*s</li>
<li>将新节点*s的数据域置为e</li>
<li>将新节点*s的指针域指向节点a<sub>i</sub></li>
<li>将节点*p的指针域指向新节点*s</li>
</ol>
</li>
<li><p>删除</p>
<ol>
<li>查找节点a<sub>i-1</sub>并由指针p指向该节点</li>
<li>临时保存待删除的节点a<sub>i</sub>的地址在q中，以备释放</li>
<li>将节点*p的指针域指向a<sub>i</sub>的直接后继节点</li>
<li>释放节点a<sub>i</sub>的空间</li>
</ol>
</li>
<li><p>创建单链表</p>
<ul>
<li>前插法</li>
<li>后插法</li>
</ul>
</li>
</ol>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h3><h3 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
